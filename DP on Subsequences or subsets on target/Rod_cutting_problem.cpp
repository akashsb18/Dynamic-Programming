// We are given a rod of size ‘N’. It can be cut into pieces. Each length of a piece has a particular price given by the price array. Our task is to find the maximum revenue that can be generated by selling the rod after cutting( if required) into pieces.

// Input
//  2 5 7 8 10

// OutPut  --> 12

// All possible partitions are:
// 1,1,1,1,1           max_cost=(2+2+2+2+2)=10
// 1,1,1,2             max_cost=(2+2+2+5)=11
// 1,1,3               max_cost=(2+2+7)=11
// 1,4                 max_cost=(2+8)=10
// 5                   max_cost=(10)=10
// 2,3                 max_cost=(5+7)=12
// 1,2,2               max _cost=(1+5+5)=12

// Clearly, if we cut the rod into lengths 1,2,2, or 2,3, we get the maximum cost which is 12.

// Solution

// Think it in terms of Knapsack
//  Try to pick length and sum them up to make N in all possible ways

// f(ind,N) --> Till index ind, what is the maximum price you can obtain ?

// RECURSION

// #include <bits/stdc++.h>
// using namespace std;

// int f(int ind, int n, vector<int> &v)
// {

//     if (ind == 0)
//     {
//         return n * v[0];
//     }

// int notTake = f(ind - 1, n, v);
// int take = -1e9;
// int rodLength = ind + 1;
// if (n >= rodLength)
// {
//     take = v[ind] + f(ind, n - rodLength, v);
// }

//     return max(notTake, take);
// }

// int main()
// {

//     vector<int> price = {3, 5, 8, 9, 1, 0, 17, 17, 20};
//     int n = price.size();

//     cout << f(n - 1, n, price);

//     return 0;
// }

// MEMOIZATION

// #include <bits/stdc++.h>
// using namespace std;

// int f(int ind, int n, vector<int> &v, vector<vector<int>> dp)
// {

//     if (ind == 0)
//     {
//         return n * v[0];
//     }

//     if (dp[ind][n] != -1)
//     {
//         return dp[ind][n];
//     }

//     int notTake = f(ind - 1, n, v, dp);
//     int take = -1e9;
//     int rodLength = ind + 1;
//     if (n >= rodLength)
//     {
//         take = v[ind] + f(ind, n - rodLength, v, dp);
//     }

//     return dp[ind][n] = max(notTake, take);
// }

// int main()
// {

// vector<int> price = {3, 5, 8, 9, 1, 0, 17, 17, 20};
// int n = price.size();

// vector<vector<int>> dp(n + 1, vector<int>(n + 1, -1));

//     cout << f(n - 1, n, price, dp);

//     return 0;
// }

// TABULATION

// #include <bits/stdc++.h>
// using namespace std;

// int main()
// {

//     vector<int> price = {3, 5, 8, 9, 1, 0, 17, 17, 20};
//     int n = price.size();

//     vector<vector<int>> dp(n, vector<int>(n + 1, 0));

//     for (int i = 0; i <= n; i++)
//     {
//         dp[0][i] = i * price[0];
//     }

//     for (int ind = 1; ind < n; ind++)
//     {
//         for (int N = 0; N <= n; N++)
//         {
//             int notTake = dp[ind - 1][N];
//             int take = -1e9;
//             int rodLength = ind + 1;
//             if (N >= rodLength)
//             {
//                 take = price[ind] + dp[ind][N - rodLength];
//             }

//             dp[ind][N] = max(notTake, take);
//         }
//     }

//     cout << dp[n - 1][n];

//     return 0;
// }

// Space optimisation

// #include <bits/stdc++.h>
// using namespace std;

// int main()
// {

//     vector<int> price = {3, 5, 8, 9, 1, 0, 17, 17, 20};
//     int n = price.size();

//     vector<int> prev(n + 1, 0);
//     vector<int> curr(n + 1, 0);

//     for (int i = 0; i <= n; i++)
//     {
//         prev[i] = i * price[0];
//     }

//     for (int ind = 1; ind < n; ind++)
//     {
//         for (int N = 0; N <= n; N++)
//         {
//             int notTake = prev[N];
//             int take = -1e9;
//             int rodLength = ind + 1;
//             if (N >= rodLength)
//             {
//                 take = price[ind] + curr[N - rodLength];
//             }

//             curr[N] = max(notTake, take);
//         }
//         prev = curr;
//     }

//     cout << prev[n];

//     return 0;
// }

// 1D space optimisings

#include <bits/stdc++.h>
using namespace std;

int main()
{

    vector<int> price = {3, 5, 8, 9, 1, 0, 17, 17, 20};
    int n = price.size();

    vector<int> prev(n + 1, 0);
    vector<int> curr(n + 1, 0);

    for (int i = 0; i <= n; i++)
    {
        prev[i] = i * price[0];
    }

    for (int ind = 1; ind < n; ind++)
    {
        for (int N = 0; N <= n; N++)
        {
            int notTake = prev[N];
            int take = -1e9;
            int rodLength = ind + 1;
            if (N >= rodLength)
            {
                take = price[ind] + curr[N - rodLength];
            }

            curr[N] = max(notTake, take);
        }
        prev = curr;
    }

    cout << prev[n];

    return 0;
}